## 垃圾收集发生的时机？
    GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收， 比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说 System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较大。  

    一般以下几种情况会发生垃圾回收
    1. 当Eden区或者S区不够用了 
    2. 老年代空间不够用了
    3. 方法区空间不够用了 
    4. System.gc()

## 内存泄漏与内存溢出的区别
- 内存泄漏:对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。
- 内存溢出:内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。

## young gc会有stw吗?
    不管什么 GC，都会有 stop-the-world，只是发生时间的长短。

## major gc和full gc的区别
    major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。

## G1与CMS的区别是什么

    CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。

    G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。

## 什么是直接内存

    直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考 虑，读写频繁的场合可能会考虑使用直接内存。

## 不可达的对象一定要被回收吗?
    即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对 象死亡，至少要经历两次标记过程;可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此 对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机 将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关 联，否则就会被真的回收。

## 方法区中的无用类回收 方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢?
    判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满 足下面 3 个条件才能算是 “无用的类” :
    该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
    加载该类的 ClassLoader 已经被回收。
    该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然 被回收。

## 不同的引用
    JDK1.2以后，Java对引用进行了扩充:强引用、软引用、弱引用和虚引用