# IOC源码分析

IOC(Inversion of Control)控制反转：所谓控制反转，就是把原先我们代码里面需要实现的对象创 建、依赖的代码，反转给容器来帮忙实现。那么必然的我们需要创建一个容器，同时需要一种描述来让 容器知道需要创建的对象与对象的关系。这个描述最具体表现就是我们所看到的配置文件。

DI(Dependency Injection)依赖注入：就是指对象是被动接受依赖类而不是自己主动去找，换句话说就 是指对象不是从容器中查找它依赖的类，而是在容器实例化对象的时候主动将它依赖的类注入给它。

## BeanFactory

 Spring Bean 的创建是典型的工厂模式，这一系列的 Bean 工厂，也即 IOC 容器为开发者管理对象 间的依赖关系提供了很多便利和基础服务，在 Spring 中有许多的 IOC 容器的实现供用户选择和使用， 其相互关系如下:
![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/cc889ab8b7fe4d539207ad14cd303fed.png
)

BeanFactory 作为最顶层的一个接口类，它定义了 IOC 容器的基本功能规范，BeanFactory 有三 个重要的子类:ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory。 但是从类图中我们可以发现最终的默认实现类是 DefaultListableBeanFactory，它实现了所有的接口。

每个接口都有它使用的场合，它 主要是为了区分在 Spring 内部在操作过程中对象的传递和转化过程时，对对象的数据访问所做的限制。 例如 ListableBeanFactory 接口表示这些 Bean 是可列表化的，而 HierarchicalBeanFactory 表示的是 这些 Bean 是有继承关系的，也就是每个 Bean 有可能有父 Bean。AutowireCapableBeanFactory 接 口定义 Bean 的自动装配规则。

ApplicationContext 是 Spring 提供的一个高级的 IOC 容器，它除了能够提供 IOC 容器的基本功能 外，还为用户提供了以下的附加服务。从 ApplicationContext 接口的实现，我们看出其特点: 
1. 支持信息源，可以实现国际化。(实现 MessageSource 接口)
2. 访问资源。(实现 ResourcePatternResolver 接口，后面章节会讲到)
3. 支持应用事件。(实现 ApplicationEventPublisher 接口)


# 基于 Xml 的 IOC 容器的初始化

ApplicationContext 系列容器也许是我们最熟悉的，因为 Web 项目中使用的 XmlWebApplicationContext 就属于这个继承体系，还有 ClasspathXmlApplicationContext 等

## 1. 寻找入口
还有一个我们用的比较多的 ClassPathXmlApplicationContext，通过 main()方法启动:
```java
ApplicationContext app = new ClassPathXmlApplicationContext("application.xml");
```
还有像 AnnotationConfigApplicationContext 、 FileSystemXmlApplicationContext 、 XmlWebApplicationContext 等都继承自父容器 AbstractApplicationContext 主要用到了装饰器模式 和策略模式，最终都是调用 refresh()方法。
```java
	public ClassPathXmlApplicationContext(
			String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
			throws BeansException {

		super(parent);
		//设置配置文件路径,
		setConfigLocations(configLocations);
		//refresh作用是防止IOC容器多次实例化
		if (refresh) {
			refresh();
		}
	}
```

## 2. 获得配置路径

