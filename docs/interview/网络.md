## 一个http请求的整个过程

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/072c4f22b264476da993618bebc6c22b.png)

## 为什么有了 MAC 层还要走 IP 层呢?

mac 地址是唯一的，那理论上，在任何两个设备之间，我应该都可以通过 mac 地址发送数据，为什么还需要 ip 地址?
 mac 地址就好像个人的身份证号，人的身份证号和人户口所在的城市，出生的日期有关， 但是和人所在的位置没有关系，人是会移动的，知道一个人的身份证号，并不能找到它这个 人，mac 地址类似，它是和设备的生产者，批次，日期之类的关联起来，知道一个设备的 mac，并不能在网络中将数据发送给它，除非它和发送方的在同一个网络内。 所以要实现机器之间的通信，我们还需要有 ip 地址的概念，ip 地址表达的是当前机器在网 络中的位置，类似于城市名+道路号+门牌号的概念。通过 ip 层的寻址，我们能知道按何种 路径在全世界任意两台 Internet 上的的机器间传输数据。



## TCP 3次握手协议？

![image](https://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/8f84458526024c84a8176c4aeebdbb10.png)

## TCP 四次挥手协议

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/2643ca4fcb4544be858cb1f7b3440b0e.png)

## 为什么连接的时候是三次握手，关闭的时候却是四次握手?

三次握手是因为因为当 Server 端收到 Client 端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时， 当 Server 端收到 FIN 报文时，很可能并不会立即关闭 SOCKET(因为可能还有消息没处理完)，所以只能先回复一个 ACK 报文，告诉 Client 端，"你发的 FIN 报文我收到了"。只有等到 我 Server 端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送。故需要四步 握手。



## TCP和UDP的区别？

1. （基于连接vs无连接）tcp是面向连接的（三次握手；四次挥手）；udp不是面向连接的
2. （重量级vs轻量级）tcp是一个重量级的协议；udp则是轻量级的协议。一个tcp数据报的报头大小最少20字节，udp数据报的包头固定8个字节
3. （可靠性）tcp交付保证：如果消息在传输中丢失，那么它将重发；udp没有交付保证，一个数据包在运输过程中可能丢失。
4. （有序性）消息到达网络的另一端可能是无序的，tcp协议将为你拍好序。Udp不提供任何有序性的保证。
5. （速度）tcp慢，适合传输大量数据；udp快，适合传输少量数据。
6. （流量控制和拥塞控制）TCP有流量控制和拥塞控制，udp没有。
7. tcp面向字节流，udp面向报文
8. tcp只能单播，不能发送广播和组播；udp可以广播和组播。

Tcp应用：邮件传输   udp应用：qq聊天、qq视频


### 二层负载
二层负载是针对 MAC，负载均衡服务器对外依然提供一个 VIP(虚 IP)，集群中不同的机器 采用相同 IP 地址，但是机器的 MAC 地址不一样。当负载均衡服务器接受到请求之后，通过 改写报文的目标 MAC 地址的方式将请求转发到目标机器实现负载均衡 二层负载均衡会通过一个虚拟 MAC 地址接收请求，然后再分配到真实的 MAC 地址
### 三层负载均衡
三层负载是针对 IP，和二层负载均衡类似，负载均衡服务器对外依然提供一个 VIP(虚 IP)， 但是集群中不同的机器采用不同的 IP 地址。当负载均衡服务器接受到请求之后，根据不同的 负载均衡算法，通过 IP 将请求转发至不同的真实服务器
三层负载均衡会通过一个虚拟 IP 地址接收请求，然后再分配到真实的 IP 地址
### 四层负载均衡
四层负载均衡工作在 OSI 模型的传输层，由于在传输层，只有 TCP/UDP 协议，这两种协议 中除了包含源 IP、目标 IP 以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受 到客户端请求后，以后通过修改数据包的地址信息(IP+端口号)将流量转发到应用服务器。 四层通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器
### 七层负载均衡
七层负载均衡工作在 OSI 模型的应用层，应用层协议较多，常用 http、radius、dns 等。七层 负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个 Web 服务器的负载均衡，除了根据 IP 加端口进行负载外，还可根据七层的 URL、浏览器类 别来决定是否要进行负载均衡
七层通过虚拟的 URL 或主机名接收请求，然后再分配到真实的服务器。

## TCP 拆包和粘包

粘包：tcp协议会将多个数据包打包成一个tcp报文发送出去。

拆包：数据包超过一次tcp报文所能传输的最大值时，就会将一个数据包拆成多个最大tcp长度的tcp报文分开传输。

## 导致tcp粘包和拆包原因

- 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包
- 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包
- 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包

## tcp粘包和拆包的解决方案

- 定长消息

  发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来

- 分隔符分割

  可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开

- 消息头中标识消息长度

   发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了

   

 






