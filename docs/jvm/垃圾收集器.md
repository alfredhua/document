![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/5b28f360bbd241cd8a26ff674f9f3ccd.png
)

## Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器，曾经(在JDK1.3.1之前)是虚拟机新生代收集的唯一选择。

它是一种单线程收集器，不仅仅意味着它只会使用一个CPU或者一条收集线程去完成垃圾收集工作，更重要的是其在进行垃圾收集的时候需要暂停其他线程。

- 优点:简单高效，拥有很高的单线程收集效率
- 缺点:收集过程需要暂停所有线程 算法:复制算法
- 适用范围:新生代 应用:Client模式下的默认新生代收集器

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/f9f71293d181412aa3189a08ad48ef1e.png
)

## ParNew收集器
可以把这个收集器理解为Serial收集器的多线程版本。

- 优点:在多CPU时，比Serial效率高。
- 缺点:收集过程暂停所有应用程序线程，单CPU时比Serial效率差。 
- 算法:复制算法
- 适用范围:新生代
- 应用:运行在Server模式下的虚拟机中首选的新生代收集器

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/8e861169a2c64b25bd6b022d0f62a5fe.png
)

## Parallel Scavenge收集器

Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，看上去和ParNew一样，但是Parallel Scanvenge更关注 系统的吞吐量。

吞吐量=运行用户代码的时间/(运行用户代码的时间+垃圾收集时间)
比如虚拟机总共运行了100分钟，垃圾收集时间用了1分钟，吞吐量=(100-1)/100=99%。

若吞吐量越大，意味着垃圾收集的时间越短，则用户代码可以充分利用CPU资源，尽快完成程序 的运算任务。

-XX:MaxGCPauseMillis控制最大的垃圾收集停顿时间，
 -XX:GCTimeRatio直接设置吞吐量的大小。

 ## Serial Old收集器

 Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，不同的是采用"标记-整理算 法"，运行过程和Serial收集器一样。

 ![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/edafe3b45e1e4d42a6bad9a7d716de74.png
)

## Parallel Old收集器

Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和"标记-整理算法"进行垃圾回收。

吞吐量优先

## CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取 最短回收停顿时间 为目标的收集器。
采用的是"标记-清除算法",整个过程分为4步
1. 初始标记 CMS initial mark ->速度很快(标记GC Roots能关 联到的对象 Stop The World)
3. 并发标记 CMS concurrent mark(进行GC Roots Tracing)           
4. 重新标记 CMS remark(修改并发标记因用户程序变动的内容 Stop The World) 		           	
2. 并发清除 CMS concurrent sweep

由于整个过程中，并发标记和并发清除，收集器线程可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行的。

- 优点:并发收集、低停顿 
- 缺点:产生大量空间碎片、并发阶段会降低吞吐量

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/4ae6ffb0369f41d0a18ba33008b8f2fc.png
)


## G1收集器

G1特点：
- 并行与并发
- 分代收集(仍然保留了分代的概念)
- 空间整合(整体上属于“标记-整理”算法，不会导致空间碎片) 可预测的停顿(比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集 上的时间不得超过N毫秒)

使用G1收集器时，Java堆的内存布局与就与其他收集器有很大差别，它将整个Java堆划分为多个 大小相等的独立区域(Region)，虽然还保留有新生代和老年代的概念，但新生代和老年代不再 是物理隔离的了，它们都是一部分Region(不需要连续)的集合。

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/a5c101afd788485998c7a8ead20adb3f.png
)

## 如何选择合适的垃圾收集器？

官网 :https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/collectors.html#sthref28

优先调整堆的大小让服务器自己来选择

- 如果内存小于100M，使用串行收集器 
- 如果是单核，并且没有停顿时间要求，使用串行或JVM自己选 
- 如果允许停顿时间超过1秒，选择并行或JVM自己选 
- 如果响应时间最重要，并且不能超过1秒，使用并发收集器 对于G1收集

JDK 7开始使用，JDK 8非常成熟，JDK 9默认的垃圾收集器，适用于新老生代。

判断是否需要使用G1收集器?
1. 50%以上的堆被存活对象占用
2. 对象分配和晋升的速度变化非常大
3. 垃圾回收时间比较长