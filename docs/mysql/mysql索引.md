## 索引是什么？

索引是为了加速对表中数据行的检索而创建的一种分散存储的 数据结构。

首先数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果 没有索引的话，要从 500 万行数据里面检索一条数据，只能依次遍历这张表的全部数据，直到找到这条数据。

但是有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是一种特殊 的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据 了。

## 索引类型

- 普通索引
  
  > 也叫非唯一索引，是最普通的索引，没有任何的限制。
- 唯一索引
  
  > 唯一索引要求键值不能重复。另外需要注意的是，主键索引是一 种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用 primay key 创建。
- 全文索引
  
  > 针对比较大的数据，比如我们存放的是消息内容，有几 KB 的数 据的这种情况，如果要解决 like 查询效率低的问题，可以创建全文索引。只有文本类型 的字段才可以创建全文索引，比如 char、varchar、text。


## 二分查找

有序数组的等值查询和比较查询效率非常高，但是更新数据的时候会出现一个问题， 可能要挪动大量的数据(改变 index)，所以只适合存储静态的数据。

为了支持频繁的修改，比如插入数据，我们需要采用链表。链表的话，如果是单链 表，它的查找效率还是不够高。

有没有可以使用二分查找的链表呢?

## 二叉查找树(BST Binary Search Tree)

左子树所有的节点都小于父节点，右子树所有的节点都大于父节点。投影到平面以 后，就是一个有序的线性表。

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/757d6f6d0ba549138847b62513ed4f84)

二叉查找树既能够实现快速查找，又能够实现快速插入。

存在的问题：

> 就是它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成
O(n)。

<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">动态演示二叉查找数</a>

如果插入的数据是一个有序的

> 它会变成链表(我们把这种树叫做“斜树”)，这种情况下不能达到加快检索速度 的目的，和顺序查找效率是没有区别的。

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/7222f1709f2843e18dade1c8f4dff020)

因为左右子树深度差太大，这棵树的左子树根本没有节点——也就是它不够平衡。 所以，我们有没有左右子树深度相差不是那么大，更加平衡的树呢?


## 平衡二叉树 (左旋转，右旋转)

平衡二叉树的定义:左右子树深度差绝对值不能超过 1。

所以为了保持平衡，AVL 树在插入和更新数据的时候执行了一系列的计算和调整的

<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html">平衡二叉树动态演示</a>

平衡二叉树作为索引怎么查询数据?

第一个是索引的键值。比如我们在 id 上面创建了一个索引，我在用 where id =1 的 条件查询的时候就会找到索引里面的 id 的这个键值。

第二个是数据的磁盘地址，因为索引的作用就是去查找数据的存放的地址。

第三个，因为是二叉树，它必须还要有左子节点和右子节点的引用，这样我们才能 找到下一个节点。比如大于 26 的时候，走右边，到下一个树的节点，继续判断。

![image](http://java-run-blog.oss-cn-zhangjiakou.aliyuncs.com/file/5a7b4f4c2fa340ac989cfcab4ed2b0f5)

如果是这样存储数据的话，我们来看一下会有什么问题。

## 为什么用索引？
- 索引能极大的减少存储引擎需要扫描的数据量
- 索引可以把随机IO变成顺序IO
- 索引可以帮助我们在进行分组、排序等操作时，避免使 用临时表

## 为什么用B+ tree？
- B+树是B-树的变种(PLUS版)多路绝对平衡查找树，他拥有B-树的优势 B+树扫库、表能力更强
- B+树的磁盘读写能力更强
- B+树的排序能力更强 B+树的查询效率更加稳定(仁者见仁、智者见智)

## 联合索引列选择原则
- 经常用的列优先 【最左匹配原则】
- 选择性(离散度)高的列优先【离散度高原则】
- 宽度小的列优先【最少空间原则】